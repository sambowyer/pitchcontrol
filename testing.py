import predict, pitchShift
from helpers import *
from PitchProfile import PitchProfile
from timeit import default_timer as timer
import soundfile as sf
from copy import deepcopy

def dictionaryToCSVLine(dictionary, algorithm, b, isCustomFFT, numDownsamples, octaveTrick, predFreq, time):
    d = dictionary.copy()
    d["algorithm"] = algorithm

    d["b"] = b
    d["isCustomFFT"] = isCustomFFT
    d["numDownsamples"] = numDownsamples
    d["octaveTrick"] = octaveTrick

    d["predFreq"] = predFreq
    d["time"] = time

    d["percentErr"] = getPercentageError(d["trueFreq"], predFreq)
    d["absMidiErr"] = getAbsoluteMIDIError(d["trueFreq"], predFreq)
    d["correctNote"] = isWithin100Cents(d["trueFreq"], predFreq)
    d["correctNoteWithOctaveErr"] = isWithin100CentsWithOctaveError(d["trueFreq"], predFreq)

    x = ""
    for val in d:
        x += str(d[val]) + ","
    return x[:-1] + "\n"

def testToCSV(signal, testInfo, csvFilePath):
    '''This function assumes that the csv file already contains headers: 
        signalType, algorithm, b, isCustomFFT, numDownsamples, octaveTrick, sampleRate, expectedMin, expectedMax, instrument, noise, extraGain, windowFunction, trueFreq, predFreq, time, percentErr, absMidiErr, correctNote, correctNoteWithOctaveErr
    ALSO assumes that *testInfo* is a dictionary with these headers as it's keys and the values being the corresponding values.
        In the case of the hyperparameter keys (b, isCustomFFT, numDownsamples, octaveTrick), the corresponding values should be a collection of all the possible values that need evaluating.
    The function then writes in the relevant data generated by predicting the pitch of 'signal' using all prediction algorithms.'''
    
    with open(csvFilePath, "a") as f:
        ##  execute predictions in the following order: 
        ##      zerocross, autocorrelation, AMDF, naiveFT, naiveFTWithPhase, cepstrum, HPS, trimmedMean (with trimSize=2/7), median

        sampleRate = testInfo["sampleRate"]
        expectedMin = testInfo["expectedMin"]
        expectedMax = testInfo["expectedMax"]

        # The following lists are already filled in to allow for indexing while we iterate through all desired hyperparameter values
        #   Since b is the only hyperparameter affecting just one algorithm its results are saved in a sub-list so that the mean & median predictions may be
        #   calculated more easily for each possible hyperparameter combination
        executionTimes = [0,0,[],0,0,0,0]
        predictions = [0,0,[],0,0,0,0]

        ## Calculations
        #zerocross
        start = timer()
        pred = predict.zerocross(signal, sampleRate)
        end = timer()

        predictions[0] = pred
        executionTimes[0] = end-start

        f.write(dictionaryToCSVLine(testInfo,"zerocross","n/a","n/a","n/a","n/a", pred, end-start))

        #autocorrelation
        start = timer()
        pred = predict.autocorrelation(signal, sampleRate, expectedMin, expectedMax)
        end = timer()

        predictions[1] = pred
        executionTimes[1] = end-start

        f.write(dictionaryToCSVLine(testInfo,"autocorrelation","n/a","n/a","n/a","n/a", pred, end-start))

        #AMDF
        for b in testInfo["b"]:
            start = timer()
            pred = predict.AMDF(signal, sampleRate, b, expectedMin, expectedMax)
            end = timer()

            predictions[2].append(pred)
            executionTimes[2].append(end-start)

            f.write(dictionaryToCSVLine(testInfo,"AMDF",b,"n/a","n/a","n/a", pred, end-start))

        for isCustomFFT in testInfo["isCustomFFT"]:
            #naiveFT
            naiveFTPredictions = []
            start = timer()
            pred = predict.naiveFT(signal, sampleRate, isCustomFFT, expectedMin, expectedMax)
            end = timer()

            predictions[3] = pred
            executionTimes[3] = end-start

            f.write(dictionaryToCSVLine(testInfo,"naiveFT","n/a",isCustomFFT,"n/a","n/a", pred, end-start))

            #naiveFTWithPhase
            naiveFTWithPhasePredictions = []
            start = timer()
            pred = predict.naiveFTWithPhase(signal, sampleRate, isCustomFFT, expectedMin, expectedMax)
            end = timer()

            predictions[4] = pred
            executionTimes[4] = end-start

            f.write(dictionaryToCSVLine(testInfo,"naiveFTWithPhase","n/a",isCustomFFT,"n/a","n/a", pred, end-start))

            #cepstrum
            cepstrumPredictions = []
            start = timer()
            pred = predict.cepstrum(signal, sampleRate, isCustomFFT, expectedMin, expectedMax)
            end = timer()

            predictions[5] = pred
            executionTimes[5] = end-start

            f.write(dictionaryToCSVLine(testInfo,"cepstrum","n/a",isCustomFFT,"n/a","n/a", pred, end-start))

            for numDownsamples in testInfo["numDownsamples"]:
                for octaveTrick in testInfo["octaveTrick"]:
                    #HPS
                    start = timer()
                    pred = predict.HPS(signal, sampleRate, isCustomFFT, numDownsamples, expectedMin, expectedMax, octaveTrick)
                    end = timer()

                    predictions[6] = pred
                    executionTimes[0] = end-start

                    f.write(dictionaryToCSVLine(testInfo,"HPS","n/a",isCustomFFT,numDownsamples,octaveTrick, pred, end-start))

                    for bIndex in range(len(testInfo["b"])):
                        #trimmedMean - excluding smallest two and largest two predictions and max
                        pred = getTrimmedMean(predictions[:2] + [predictions[2][bIndex]] + predictions[3:], 2/7)
                        time = sum(executionTimes[:2] + [executionTimes[2][bIndex]] + executionTimes[3:])

                        f.write(dictionaryToCSVLine(testInfo,"trimmedMean",testInfo["b"][bIndex],isCustomFFT,numDownsamples,octaveTrick, pred, time))

                        #median
                        pred = getMedian(predictions[:2] + [predictions[2][bIndex]] + predictions[3:])

                        f.write(dictionaryToCSVLine(testInfo,"median",testInfo["b"][bIndex],isCustomFFT,numDownsamples,octaveTrick, pred, time))

def getPitchDataMeanErrors(expectedPitchData, actualPitchData):
    '''Assumes both arguments are lists of frequency predictions with the same time spacing between data points.
    Returns a list of the form 
        [meanPercentError, meanAbsoluteMidiError, meanCorrectNote, meanCorrectNoteWithOctaveError]
    with each of those values defined as in helpers.py and analyse.py.'''
    numDataPoints = min(len(expectedPitchData), len(actualPitchData))
    meanErrors = [0,0,0,0]

    for i in range(numDataPoints):
        meanErrors[0] += getPercentageError(expectedPitchData[i], actualPitchData[i])
        meanErrors[1] += getAbsoluteMIDIError(expectedPitchData[i], actualPitchData[i])
        meanErrors[2] += isWithin100Cents(expectedPitchData[i], actualPitchData[i])
        meanErrors[3] += isWithin100CentsWithOctaveError(expectedPitchData[i], actualPitchData[i])

    return [x/numDataPoints for x in meanErrors]

def ratioTestToCSV(originalPitchProfile, scalingFactor, csvFilePath, verbose=False, saveFile=None):
    '''This function assumes that the csv file already contains headers: 
        signalType, sampleRate, expectedMin, expectedMax, instrument, blockSize, scalingFactor, time, meanPercentErr, meanAbsMidiErr, meanCorrectNote, meanCorrectNoteWithOctaveErr'''
    signal, sampleRate = sf.read(originalPitchProfile.location, always_2d=True)
    signal = toMono(signal)

    start = timer()
    shiftedSignal = pitchShift.phaseVocoderPitchShift(signal, sampleRate, scalingFactor, windowLength=originalPitchProfile.blockSize//2, overlapLength=3*originalPitchProfile.blockSize//8, windowFunction=getHanningWindow(originalPitchProfile.blockSize//2))
    end = timer()

    sf.write("temp.wav", shiftedSignal, sampleRate)

    if saveFile != None:
        sf.write(saveFile, shiftedSignal, sampleRate)

    shiftedPitchProfile = PitchProfile("temp.wav", sampleRate, "naiveFTWithPhase", {"isCustomFFT" : False}, originalPitchProfile.instrument, blockSize=originalPitchProfile.blockSize, overlap=originalPitchProfile.overlap, customName=originalPitchProfile.name+"SHIFTED")
    shiftedPitchProfile.analysePitch()
    
    if verbose:
        originalPitchProfile.printLog()
        shiftedPitchProfile.printLog()

    expectedPitchData = [x*scalingFactor for x in originalPitchProfile.pitchData]

    pitchDataMeanErrors = getPitchDataMeanErrors(expectedPitchData, shiftedPitchProfile.pitchData)

    with open(csvFilePath, "a") as f:
        f.write("%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n" % (originalPitchProfile.name, sampleRate, originalPitchProfile.detectionParams["expectedMin"], originalPitchProfile.detectionParams["expectedMax"], originalPitchProfile.instrument, originalPitchProfile.blockSize, scalingFactor, end-start, pitchDataMeanErrors[0], pitchDataMeanErrors[1], pitchDataMeanErrors[2], pitchDataMeanErrors[3]))


def correctingTestToCSV(originalPitchProfile, correctNotes, correctingTo, csvFilePath, verbose=False, saveFile=None):
    '''This function assumes that the csv file already contains headers: 
        signalType, sampleRate, expectedMin, expectedMax, instrument, blockSize, correctingTo, time, meanPercentErr, meanAbsMidiErr, meanCorrectNote, meanCorrectNoteWithOctaveErr'''
    sampleRate = originalPitchProfile.sampleRate

    start = timer()
    shiftedSignal = pitchShift.correctPitch(originalPitchProfile, correctNotes)
    end = timer()

    sf.write("temp.wav", shiftedSignal, sampleRate)

    if saveFile != None:
        sf.write(saveFile, shiftedSignal, sampleRate)

    shiftedPitchProfile = PitchProfile("temp.wav", sampleRate, "naiveFTWithPhase", {"isCustomFFT" : False}, originalPitchProfile.instrument, blockSize=originalPitchProfile.blockSize, overlap=originalPitchProfile.overlap, customName=originalPitchProfile.name+"SHIFTED")
    shiftedPitchProfile.analysePitch()
    if verbose:
        originalPitchProfile.printLog()
        shiftedPitchProfile.printLog()

    originalPitchProfileCOPY = deepcopy(originalPitchProfile)
    originalPitchProfileCOPY.autoCorrectPitchData(correctNotes)

    expectedPitchData = originalPitchProfileCOPY.pitchData

    pitchDataMeanErrors = getPitchDataMeanErrors(expectedPitchData, shiftedPitchProfile.pitchData)

    with open(csvFilePath, "a") as f:
        f.write("%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n" % (originalPitchProfile.name, sampleRate, originalPitchProfile.detectionParams["expectedMin"], originalPitchProfile.detectionParams["expectedMax"], originalPitchProfile.instrument, originalPitchProfile.blockSize, correctingTo, end-start, pitchDataMeanErrors[0], pitchDataMeanErrors[1], pitchDataMeanErrors[2], pitchDataMeanErrors[3]))


def matchingTestToCSV(originalPitchProfile, matchingPitchProfile, csvFilePath, verbose=False, saveFile=None):
    '''This function assumes that the csv file already contains headers: 
        signalType, sampleRate, expectedMin, expectedMax, instrument, blockSize, matchingSignalType, matchingSampleRate matchingExpectedMin, matchingExpectedMax, matchingIntrument, matchingBlockSize, time, meanPercentErr, meanAbsMidiErr, meanCorrectNote, meanCorrectNoteWithOctaveErr
    ALSO assumes that *testInfo* is a dictionary with these headers as it's keys and the values being the corresponding values.'''
    sampleRate = originalPitchProfile.sampleRate

    start = timer()
    shiftedSignal = pitchShift.matchPitch(originalPitchProfile, matchingPitchProfile)
    end = timer()

    sf.write("temp.wav", shiftedSignal, sampleRate)

    if saveFile != None:
        sf.write(saveFile, shiftedSignal, sampleRate)

    shiftedPitchProfile = PitchProfile("temp.wav", sampleRate, "naiveFTWithPhase", {"isCustomFFT" : False}, originalPitchProfile.instrument, blockSize=originalPitchProfile.blockSize, overlap=originalPitchProfile.overlap, customName=originalPitchProfile.name+"SHIFTED")
    shiftedPitchProfile.analysePitch()
    if verbose:
        originalPitchProfile.printLog()
        matchingPitchProfile.printLog()
        shiftedPitchProfile.printLog()

    expectedPitchData = matchingPitchProfile.pitchData

    pitchDataMeanErrors = getPitchDataMeanErrors(expectedPitchData, shiftedPitchProfile.pitchData)

    with open(csvFilePath, "a") as f:
        f.write("%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n" % (originalPitchProfile.name, sampleRate, originalPitchProfile.detectionParams["expectedMin"], originalPitchProfile.detectionParams["expectedMax"], originalPitchProfile.instrument, originalPitchProfile.blockSize, matchingPitchProfile.name, sampleRate, matchingPitchProfile.detectionParams["expectedMin"], matchingPitchProfile.detectionParams["expectedMax"], matchingPitchProfile.instrument, matchingPitchProfile.blockSize, end-start, pitchDataMeanErrors[0], pitchDataMeanErrors[1], pitchDataMeanErrors[2], pitchDataMeanErrors[3]))
  